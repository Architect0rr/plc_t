#!/usr/bin/python
"""trigger.py

trigger.py is a tool for triggering (e. g. cameras) through the DTR pins (pin 4 for DE-9, pin 20 for DB-25) on serial ports. It takes about 0.2 ms to 0.3 ms to set DTR to high with the default boudrate and a USB-to-serial converter. Also the simultaneousness of the trigger signal generated by different threads with this tool has an offset. Normally you could expect a synchronism of less than 1 ms. Setting the governor of cpufrequency to performance enhances the simultaneousness.

Check the input of your box to trigger (e. g. camera). In my case the cameras need only positive voltages up to 5 V. Therefore a foto diode did the job of cutting the negativ part and reducing the voltage. Furthermore you should set the camera to use the external trigger (ON) and rising edge (In my measurement the rising edge was much sharper than the falling edge.). We used edge triggering (Trigger_Mode_0).

Author: Daniel Mohr
Date: 2013-11-08
"""

__trigger_date__ = "2013-11-08"
__trigger_version__ = __trigger_date__

import argparse
import logging
import os
import serial
import tempfile
import threading
import time

from plc_tools.plclogclasses import QueuedWatchedFileHandler

class trigger_thread:
    def __init__(self, log, Ton, simulate, serialdevname, serialdev, m, offset, mainlock, maincondition,mylock,t0,T,n,imax,method):
        self.log = log
        self.Ton = Ton
        self.simulate = simulate
        self.serialdevname = serialdevname
        self.serialdev = serialdev
        self.m = m
        self.offset = offset
        self.i = self.m
        self.mainlock = mainlock
        self.maincondition = maincondition
        self.mylock = mylock
        self.t0 = t0
        self.T = T
        self.n = n
        self.imax = imax
        self.method = method
        self.triggertime = 0
        self.running = True
        self.thread = threading.Thread(target=self.loop)
        self.thread.daemon = True
        self.thread.name = "loop for '%s'" % serialdevname
        self.thread.start()
    def loop(self):
        if self.method == 1:
            self.log.debug("start loop for device '%s' (method: 1)" % self.serialdevname)
            if self.simulate:
                while self.running:
                    self.do_trigger_simulated1()
            else:
                while self.running:
                    self.do_trigger1()
            self.log.debug("stop loop for device '%s' (method: 1)" % self.serialdevname)
        elif self.method == 2:
            self.log.debug("start loop for device '%s' (method: 2)" % self.serialdevname)
            if self.simulate:
                while self.running:
                    self.do_trigger_simulated2()
            else:
                while self.running:
                    self.do_trigger2()
            self.log.debug("stop loop for device '%s'" % self.serialdevname)
        else: # method == 3
            self.log.debug("start loop for device '%s' (method: 3)" % self.serialdevname)
            self.mylock.acquire()
            self.maincondition.acquire()
            self.maincondition.release()
            if self.simulate:
                do_trigger = self.do_trigger_simulated3
            else:
                do_trigger = self.do_trigger3
            TT = self.t0 + self.T
            if self.n > 0:
                for i in range(self.n):
                    do_trigger(TT)
                    TT += self.T
            else:
                while self.running:
                    do_trigger(TT)
                    TT += self.T
            self.log.debug("stop loop for device '%s'" % self.serialdevname)
            self.mylock.release()
        self.running = False
            
    def do_trigger_simulated1(self):
        self.mylock.acquire()
        self.maincondition.acquire()
        self.maincondition.release()
        if self.i % self.m == self.offset:
            self.log.info("%f '%s' do trigger (simulated)" % (time.time(),self.serialdevname))
            self.log.debug("%f '%s' trigger True (simulated)" % (time.time(),self.serialdevname))
            time.sleep(self.Ton)
            self.log.debug("%f '%s' trigger      False (simulated)" % (time.time(),self.serialdevname))
            self.i = self.i - self.m
        self.i = self.i + 1
        self.mylock.release()
        self.mainlock.acquire()
        self.mainlock.release()
    def do_trigger1(self):
        self.mylock.acquire()
        self.maincondition.acquire()
        self.maincondition.release()
        if self.i % self.m == self.offset:
            self.log.info("%f '%s' do trigger" % (time.time(),self.serialdevname))
            self.serialdev.setDTR(level=True)
            self.log.debug("%f '%s' trigger True" % (time.time(),self.serialdevname))
            time.sleep(self.Ton)
            self.serialdev.setDTR(level=False)
            self.log.debug("%f '%s' trigger      False" % (time.time(),self.serialdevname))
            self.i = self.i - self.m
        self.i = self.i + 1
        self.mylock.release()
        self.mainlock.acquire()
        self.mainlock.release()
    def do_trigger_simulated2(self):
        self.mylock.acquire()
        self.maincondition.acquire()
        self.maincondition.release()
        if self.i % self.m == self.offset:
            time.sleep(max(0.0,self.triggertime-time.time()))
            self.log.info("%f '%s' do trigger (simulated)" % (time.time(),self.serialdevname))
            self.log.debug("%f '%s' trigger True (simulated)" % (time.time(),self.serialdevname))
            time.sleep(self.Ton)
            self.log.debug("%f '%s' trigger      False (simulated)" % (time.time(),self.serialdevname))
            self.i = self.i - self.m
        self.i = self.i + 1
        self.mylock.release()
        self.mainlock.acquire()
        self.mainlock.release()
    def do_trigger2(self):
        self.mylock.acquire()
        self.maincondition.acquire()
        self.maincondition.release()
        if self.i % self.m == self.offset:
            time.sleep(max(0.0,self.triggertime-time.time()))
            self.log.info("%f '%s' do trigger" % (time.time(),self.serialdevname))
            self.serialdev.setDTR(level=True)
            self.log.debug("%f '%s' trigger True" % (time.time(),self.serialdevname))
            time.sleep(self.Ton)
            self.serialdev.setDTR(level=False)
            self.log.debug("%f '%s' trigger      False" % (time.time(),self.serialdevname))
            self.i = self.i - self.m
        self.i = self.i + 1
        self.mylock.release()
        self.mainlock.acquire()
        self.mainlock.release()

    def do_trigger_simulated3(self,TT):
        if self.i % self.m == self.offset:
            time.sleep(max(0.0,TT-time.time()))
            self.log.info("%f '%s' do trigger (simulated)" % (time.time(),self.serialdevname))
            self.log.debug("%f '%s' trigger True (simulated)" % (time.time(),self.serialdevname))
            time.sleep(self.Ton)
            self.log.debug("%f '%s' trigger      False (simulated)" % (time.time(),self.serialdevname))
            self.i = self.i - self.m
        self.i = self.i + 1
    def do_trigger3(self,TT):
        if self.i % self.m == self.offset:
            time.sleep(max(0.0,TT-time.time()))
            self.log.info("%f '%s' do trigger" % (time.time(),self.serialdevname))
            self.serialdev.setDTR(level=True)
            self.log.debug("%f '%s' trigger True" % (time.time(),self.serialdevname))
            time.sleep(self.Ton)
            self.serialdev.setDTR(level=False)
            self.log.debug("%f '%s' trigger      False" % (time.time(),self.serialdevname))
            self.i = self.i - self.m
        self.i = self.i + 1

def main():
    help = ""
    help += "Examples:\n"
    help += "   trigger.py -simulate -debug 1 -device dev1 dev2 dev3\n"
    help += "   trigger.py -simulate -debug 1 -device dev1 dev2 -n 3 -framerate 10\n"
    help += "   trigger.py -simulate -debug 1 -device dev1 dev2 dev3 -n 4 -framerate 60 -m 1 2 4\n"
    help += "   trigger.py -simulate -debug 1 -device dev1 dev2 dev3 -n 30 -framerate 75 -m 2 3 5\n"
    help += "   trigger.py -simulate -device dev1 dev2 -n 10 -framerate 1 -m 2 2 -offset 0 1\n"
    parser = argparse.ArgumentParser(
        description='trigger.py is a tool for triggering (e. g. cameras) through the DTR pins (pin 4 for DE-9, pin 20 for DB-25) on serial ports. It takes about 0.2 ms to 0.3 ms to set DTR to high with the default boudrate and a USB-to-serial converter. Also the simultaneousness of the trigger signal generated by different threads with this tool has an offset. Normally you could expect a synchronism of less than 1 ms. Setting the governor of cpufrequency to performance enhances the simultaneousness.\nCheck the input of your box to trigger (e. g. camera). In my case the cameras need only positive voltages up to 5 V. Therefore a foto diode did the job of cutting the negativ part and reducing the voltage. Furthermore you should set the camera to use the external trigger (ON) and rising edge (In my measurement the rising edge was much sharper than the falling edge.). We used edge triggering (Trigger_Mode_0).',
        epilog="Author: Daniel Mohr\nDate: %s\nLicense: GNU GENERAL PUBLIC LICENSE, Version 3, 29 June 2007.\n\n%s" % (__trigger_date__,help),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-device',
                        nargs="+",
                        default="",
                        type=str,
                        required=True,
                        dest='device',
                        help='Set the external device(s) dev to communicate with.',
                        metavar='dev')
    parser.add_argument('-logfile',
                        nargs=1,
                        default=os.path.join(tempfile.gettempdir(),"trigger.log"),
                        type=str,
                        required=False,
                        dest='logfile',
                        help='Set the logfile to f. The WatchedFileHandler is used. This means, the logfile grows indefinitely until an other process (e. g. logrotate or the user itself) move or delete the logfile. Under Windows moving or deleting of open files is impossible and therefore the logfile grows indefinitely. default: %s' % os.path.join(tempfile.gettempdir(),"trigger.log"),
                        metavar='f')
    parser.add_argument('-framerate',
                        nargs=1,
                        default=3.0,
                        type=float,
                        required=False,
                        dest='framerate',
                        help='Set the rate of the master trigger. If you trigger a camera, this is the framerate. This master trigger triggers the trigger threads for every device. For every trigger thread you can set a variable m to control the triggering, see below. default: 3.0',
                        metavar='n')
    parser.add_argument('-m',
                        nargs="+",
                        default=0,
                        type=int,
                        required=False,
                        dest='m',
                        help='For every device set a variable m. Only every m times of the master trigger, this device will be triggered. m has to be an integer. (optional, default: 1 ... 1)',
                        metavar='i')
    parser.add_argument('-offset',
                        nargs="+",
                        default=0,
                        type=int,
                        required=False,
                        dest='offset',
                        help='For every device set a variable offset. This is an offset for m. offset has to be an integer. (optional, default: 0 ... 0)',
                        metavar='i')
    parser.add_argument('-n',
                        nargs=1,
                        default=-1,
                        type=int,
                        required=False,
                        dest='n',
                        help='Set the number of trigger signals. default: -1 (trigger forever)',
                        metavar='n')
    parser.add_argument('-imax',
                        nargs=1,
                        default=65535,
                        type=int,
                        required=False,
                        dest='imax',
                        help='If n == -1 (trigger forever) every imax times the measurement of accurateness starts new. This means every imax trigger signal is not perfect. default: 65535 (unsigned short int)',
                        metavar='imax')
    parser.add_argument('-Tonfactor',
                        nargs=1,
                        default=2.0,
                        type=float,
                        required=False,
                        dest='Tonfactor',
                        help='The trigger signal set the DTR to high for a short time. Per default every T = 1/framerate seconds a trigger signal is generated and after Ton = T/factor seconds the DTR is set to low again. default: 2.0',
                        metavar='factor')
    parser.add_argument('-baudrate',
                        nargs=1,
                        default=57600,
                        type=int,
                        required=False,
                        dest='baudrate',
                        help='Set the boudrate of the device. Typical values are: 9600, 19200, 38400, 57600, 115200. default: 57600',
                        metavar='b')
    parser.add_argument('-debug',
                        nargs=1,
                        default=0,
                        type=int,
                        required=False,
                        dest='debug',
                        help='Set debug level. 0 no debug info (default); 1 debug to STDOUT.',
                        metavar='debug_level')
    parser.add_argument('-simulate',
                        default=False,
                        required=False,
                        action='store_true',
                        dest='simulate',
                        help='By specifying this flag no data will be written to the device(s).')
    parser.add_argument('-method',
                        nargs=1,
                        default=1,
                        type=int,
                        required=False,
                        dest='method',
                        help='Set the method 1, 2 or 3. default: 1',
                        metavar='i')
    parser.add_argument('-addtime',
                        nargs=1,
                        default=5e-3,
                        type=float,
                        required=False,
                        dest='addtime',
                        help='Additional time for method 2. default: 5e-3',
                        metavar='t')
    args = parser.parse_args()
    if not isinstance(args.logfile,str):
        args.logfile = args.logfile[0]
    if not isinstance(args.framerate,float):
        args.framerate = args.framerate[0]
    if isinstance(args.m,int):
        args.m = len(args.device) * [1]
    else:
        for i in range(len(args.device)-len(args.m)):
            args.m += [1]
    args.m = args.m[0:len(args.device)]
    if isinstance(args.offset,int):
        args.offset = len(args.device) * [0]
    else:
        for i in range(len(args.device)-len(args.offset)):
            args.offset += [0]
    args.offset = args.offset[0:len(args.device)]
    if not isinstance(args.n,int):
        args.n = args.n[0]
    if not isinstance(args.imax,int):
        args.imax = args.imax[0]
    if not isinstance(args.Tonfactor,float):
        args.Tonfactor = args.Tonfactor[0]
    if not isinstance(args.baudrate,int):
        args.baudrate = args.baudrate[0]
    if not isinstance(args.debug,int):
        args.debug = args.debug[0]
    if not isinstance(args.simulate,bool):
        args.simulate = args.simulate[0]
    if not isinstance(args.method,int):
        args.method = args.method[0]
    if not isinstance(args.addtime,float):
        args.addtime = args.addtime[0]
    args.addtime = float(args.addtime)
    # initialize logging
    log = logging.getLogger('trigger')
    log.setLevel(logging.DEBUG) # logging.DEBUG = 10
    # create file handler
    fh = QueuedWatchedFileHandler(args.logfile)
    fh.setLevel(logging.DEBUG)
    fh.setFormatter(logging.Formatter('%(created)f %(levelname)s %(message)s'))
    # create console handler
    ch = logging.StreamHandler()
    if args.debug > 0:
        ch.setLevel(logging.DEBUG) # logging.DEBUG = 10
    else:
        ch.setLevel(logging.INFO)
    ch.setFormatter(logging.Formatter('%(asctime)s %(name)s %(message)s',datefmt='%H:%M:%S'))
    log.addHandler(ch)
    # add the handlers to log
    log.addHandler(fh)
    log.addHandler(ch)
    log.info("start logging: %s" % time.strftime("%a, %d %b %Y %H:%M:%S %z %Z", time.localtime()))
    # open devices
    serialdevs = []
    serialdevnames = []
    for dn in args.device:
        serialdevnames += [dn]
        if args.simulate:
            serialdevs += [None]
            log.debug("device '%s' open (simulated)" % dn)
        else:
            serialdevs += [serial.Serial(dn,args.baudrate,timeout=1,dsrdtr=True)]
            log.debug("device '%s' open" % dn)
    log.debug("%d devices" % len(serialdevnames))
    T = 1.0/args.framerate # trigger interval, trigger every T seconds
    Ton = T/args.Tonfactor
    # create lock
    mainlock = threading.Lock()
    maincondition = threading.Condition()
    maincondition.acquire()
    # start threads and set DTR to False
    t0 = time.time()
    th = []
    threadlocks = []
    for i in range(len(serialdevnames)):
        if not args.simulate:
                serialdevs[i].setDTR(level=False)
        threadlocks += [threading.Lock()]
        th += [trigger_thread(log,Ton,args.simulate,serialdevnames[i],serialdevs[i],args.m[i],args.offset[i],mainlock,maincondition,threadlocks[i],t0,T,args.n,args.imax,args.method)]
    # trigger
    if args.method == 1:
        if args.n > 0:
            log.debug("start triggering %d times (method: 1)" % args.n)
            start = time.time()
            TT = start
            for i in range(args.n-1):
                mainlock.acquire()
                log.debug("%f trigger" % time.time())
                maincondition.notify_all()
                maincondition.release() # now all threads do the trigger
                for j in range(len(serialdevnames)):
                    threadlocks[j].acquire()
                maincondition.acquire() # now all threads did the trigger
                for j in range(len(serialdevnames)):
                    threadlocks[j].release()
                mainlock.release() # now all threads start again their loop
                TT += T
                time.sleep(max(0.0,TT-time.time()))
            end2 = time.time()
            log.debug("triggered %d times in %f seconds: rate = %f" % (args.n-1,end2-start,(args.n-1)/(end2-start)))
        else:
            log.debug("start triggering (forever) (method: 1)")
            i = 0
            imax = args.imax
            start = time.time()
            while True:
                mainlock.acquire()
                log.debug("%f trigger" % time.time())
                maincondition.notify_all()
                maincondition.release() # now all threads do the trigger
                for j in range(len(serialdevnames)):
                    threadlocks[j].acquire()
                maincondition.acquire() # now all threads did the trigger
                for j in range(len(serialdevnames)):
                    threadlocks[j].release()
                mainlock.release() # now all threads start again their loop
                if i == imax:
                    start = end+T
                    i = 0
                else:
                    i += 1
                start += T
                end = time.time()
                time.sleep(max(0.0,start-end))
        # stop threads
        mainlock.acquire()
        for i in range(len(serialdevnames)):
            th[i].running = False
        log.debug("%f trigger" % time.time())
        maincondition.notify_all()
        maincondition.release() # now all threads do the trigger
        for j in range(len(serialdevnames)):
            threadlocks[j].acquire()
        maincondition.acquire() # now all threads did the trigger
        for j in range(len(serialdevnames)):
            threadlocks[j].release()
        mainlock.release() # now all threads start again their loop
        end = time.time()
        time.sleep(0.02)
        maincondition.release()
        time.sleep(0.03)
    elif args.method == 2:
        if args.n > 0:
            log.debug("start triggering %d times (method: 2)" % args.n)
            start = time.time()
            TT = time.time()
            for i in range(args.n-1):
                mainlock.acquire()
                maincondition.notify_all()
                maincondition.release() # now all threads do the trigger
                time.sleep(max(0.0,TT-time.time()))
                log.debug("%f trigger" % time.time())
                for j in range(len(serialdevnames)):
                    threadlocks[j].acquire()
                maincondition.acquire() # now all threads did the trigger
                TT += T
                for j in range(len(serialdevnames)):
                    th[j].triggertime = TT
                    threadlocks[j].release()
                mainlock.release() # now all threads start again their loop
                time.sleep(max(0.0,TT-time.time()-args.addtime))
            end2 = time.time()
            log.debug("triggered %d times in %f seconds: rate = %f" % (args.n-1,end2-start,(args.n-1)/(end2-start)))
        else:
            log.debug("start triggering (forever) (method: 2)")
            i = 0
            imax = args.imax
            start = time.time()
            while True:
                mainlock.acquire()
                maincondition.notify_all()
                maincondition.release() # now all threads do the trigger
                time.sleep(max(0.0,start-time.time()))
                log.debug("%f trigger" % time.time())
                for j in range(len(serialdevnames)):
                    threadlocks[j].acquire()
                maincondition.acquire() # now all threads did the trigger
                if i == imax:
                    start = end+T
                    i = 0
                else:
                    i += 1
                start += T
                for j in range(len(serialdevnames)):
                    th[j].triggertime = start
                    threadlocks[j].release()
                mainlock.release() # now all threads start again their loop
                end = time.time()
                time.sleep(max(0.0,start-end-args.addtime))
        # stop threads
        mainlock.acquire()
        for i in range(len(serialdevnames)):
            th[i].running = False
        log.debug("%f trigger" % time.time())
        maincondition.notify_all()
        maincondition.release() # now all threads do the trigger
        for j in range(len(serialdevnames)):
            threadlocks[j].acquire()
        maincondition.acquire() # now all threads did the trigger
        for j in range(len(serialdevnames)):
            threadlocks[j].release()
        mainlock.release() # now all threads start again their loop
        end = time.time()
        time.sleep(0.02)
        maincondition.release()
        time.sleep(0.03)
    else: # args.method == 3
        time.sleep(T/2.0)
        maincondition.notify_all()
        maincondition.release() # now all threads do their job
        log.debug("%f trigger" % time.time())
        for j in range(len(serialdevnames)):
            while not threadlocks[j].acquire(False):
                time.sleep(0.1/len(serialdevnames))
        for j in range(len(serialdevnames)):
            threadlocks[j].release()

    # close devices
    for i in range(len(serialdevnames)):
        if args.simulate:
            log.debug("device '%s' close (simulated)" % serialdevnames[i])
        else:
            serialdevs[i].close()
            log.debug("device '%s' close" % serialdevnames[i])
    time.sleep(0.1)

if __name__ == "__main__":
    main()
